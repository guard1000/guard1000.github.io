---
layout: posts
title:  "[백준] 나무 자르기"
categories: ['Algorithm', '백준']

---

[문제링크](https://www.acmicpc.net/problem/2805)

<br/>



# 나무 자르기

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 1 초      | 256 MB      | 72052 | 20773 | 12925     | 25.864%   |

<br/>



## 문제

상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를 이용해서 나무를 구할것이다.

목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.

상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.

<br/>



## 입력

첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)

둘째 줄에는 나무의 높이가 주어진다. 나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.

## 출력

적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.

<br/>



## 예제 입력 1

```
4 7
20 15 10 17
```

## 예제 출력 1 

```
15
```

<br/>



## 예제 입력 2

```
5 20
4 42 40 26 46
```

## 예제 출력 2

```
36
```

<br/>



### Sol

제가 좋아하는 이분탐색 문제입니다.

처음 알고리즘/코딩테스트 준비를 할 때 가장 많이 마주하는 문제는 Time limit 였던 것 같습니다.

문제는 어떻게 풀어야 할 지 알겠는데, 제한시간으로 통과하지 못할 때가 가장 억울했던(?) 기억이 나네요.

그러다 보니 자연스럽게 시간을 줄일 수 있는 풀이들을 찾아보게 되었었는데,

이분탐색을 처음 적용하게 되었을 땐 그 간결한 풀이방법과 효율성에 감탄했던 경험이 있습니다 ㅎㅎㅎ



<br/>

이분탐색 문제들에 익숙해지고 싶은 분들에겐 프로그래머스의 고득점 kit 이분탐색 문제들을 추천합니다!

(조만간 이 문제들도 post를 작성할 예정입니다.)

[프로그래머스-입국심사](https://programmers.co.kr/learn/courses/30/lessons/43238)

[프로그래머스-징검다리](https://programmers.co.kr/learn/courses/30/lessons/43236)



<br/>

저는 이분탐색을 할 때 '문제에서 최종적으로 구하고자 하는 것' 을 answer로 잡고 left와 right를 통해 탐색 범위를 절반씩 줄여가는 것을 선호합니다.

이 문제에서는 '절단기에 설정할 높이' 를 answer로 잡고 풀이를 세웠습니다.

<br/>

그럼 answer가 가질 수 있는 최솟값과 최댓값은 어떻게 될까요?

최솟값은 0인 경우, 상근이는 모든 나무를 그대로 들고갈 것입니다.

입력받은 나무들 중 가장 큰 나무의 높이 이상으로 설정할 경우, 상근이는 항상 0만큼 나무를 가져갈 것이므로,

최댓값은 max(입력된 나무들 크기) 로 초기화하면 됩니다.

즉 l = 0, r = max(A) 로 설정합니다. (A는 입력받은 나무 리스트)

<br/>



이후엔 left < right 인 조건 아래에서 이분탐색을 진행합니다.

answer = (l + r) / /2 로 left와 right의 중간값일 경우, 상근이가 들고갈 수 있는 나무의 양을 구합니다.

처음엔 tmp = sum([max(0, _-answer) for _ in A]) 로 코드를 작성했는데 시간초과가 나오길래

tmp =  sum(_-answer if _ > answer else 0 for _ in A) 로 바꿔주니 통과하였습니다.

<br/>

이젠 tmp와 M을 비교합니다.

최소 요구량인 M보다 많이 들고간다면 (tmp > M인 경우) answer후보군에 넣어 주고

left를 answer+1 값으로 옮겨줍니다.

반대로 tmp < M인 경우엔 right를 answer-1로 갱신해 주면 되겠지요.

이제부턴 탐색의 범위가 절반으로 줄어드는 효과가 있습니다.

물론 tmp == M 인 경우라면, 더 이상 탐색을 할 필요 없이 answer를 찾은 경우이니 break를 걸어 줍시다!

<br/>

이진탐색 원리 자체는 간단하므로 바로 아래 그림을 보면 이해가 쉬울 것 입니다.

1)번 부터 어떤 식으로 left, right, answer가 어떻게 변해가는지를 문제에서 나온 예제를 통해 확인해 봅시다. 

![image-20210628165808449](https://github.com/guard1000/guard1000.github.io/blob/master/imgs/%5BBJ%5D%20Wood%20Cutting_1.png?raw=true)

</br>



### Code

```python
# 이진탐색으로 풀어보자
N, M = map(int, input().split())
A = list(map(int, input().split()))
answers = []

l, r = 0, max(A)
while not r < l:
    answer = (l + r) // 2
    tmp = sum(_-answer if _ > answer else 0 for _ in A)
    if tmp == M:
        answers.append(answer)
        break

    elif tmp > M:
        answers.append(answer)
        l = answer+1
    else:
        r = answer-1

print(max(answers))
```

